{"ast":null,"code":"'use strict';\n\n/**\n * @license Angular v<unknown>\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n/**\n * @fileoverview\n * @suppress {globalThis,undefinedVars}\n */\nZone.__load_patch('Error', (global, Zone, api) => {\n  /*\n   * This code patches Error so that:\n   *   - It ignores un-needed stack frames.\n   *   - It Shows the associated Zone for reach frame.\n   */\n  const zoneJsInternalStackFramesSymbol = api.symbol('zoneJsInternalStackFrames');\n  const NativeError = global[api.symbol('Error')] = global['Error'];\n  // Store the frames which should be removed from the stack frames\n  const zoneJsInternalStackFrames = {};\n  // We must find the frame where Error was created, otherwise we assume we don't understand stack\n  let zoneAwareFrame1;\n  let zoneAwareFrame2;\n  let zoneAwareFrame1WithoutNew;\n  let zoneAwareFrame2WithoutNew;\n  let zoneAwareFrame3WithoutNew;\n  global['Error'] = ZoneAwareError;\n  const stackRewrite = 'stackRewrite';\n  const zoneJsInternalStackFramesPolicy = global['__Zone_Error_BlacklistedStackFrames_policy'] || global['__Zone_Error_ZoneJsInternalStackFrames_policy'] || 'default';\n  function buildZoneFrameNames(zoneFrame) {\n    let zoneFrameName = {\n      zoneName: zoneFrame.zone.name\n    };\n    let result = zoneFrameName;\n    while (zoneFrame.parent) {\n      zoneFrame = zoneFrame.parent;\n      const parentZoneFrameName = {\n        zoneName: zoneFrame.zone.name\n      };\n      zoneFrameName.parent = parentZoneFrameName;\n      zoneFrameName = parentZoneFrameName;\n    }\n    return result;\n  }\n  function buildZoneAwareStackFrames(originalStack, zoneFrame, isZoneFrame = true) {\n    let frames = originalStack.split('\\n');\n    let i = 0;\n    // Find the first frame\n    while (!(frames[i] === zoneAwareFrame1 || frames[i] === zoneAwareFrame2 || frames[i] === zoneAwareFrame1WithoutNew || frames[i] === zoneAwareFrame2WithoutNew || frames[i] === zoneAwareFrame3WithoutNew) && i < frames.length) {\n      i++;\n    }\n    for (; i < frames.length && zoneFrame; i++) {\n      let frame = frames[i];\n      if (frame.trim()) {\n        switch (zoneJsInternalStackFrames[frame]) {\n          case 0 /* FrameType.zoneJsInternal */:\n            frames.splice(i, 1);\n            i--;\n            break;\n          case 1 /* FrameType.transition */:\n            if (zoneFrame.parent) {\n              // This is the special frame where zone changed. Print and process it accordingly\n              zoneFrame = zoneFrame.parent;\n            } else {\n              zoneFrame = null;\n            }\n            frames.splice(i, 1);\n            i--;\n            break;\n          default:\n            frames[i] += isZoneFrame ? ` [${zoneFrame.zone.name}]` : ` [${zoneFrame.zoneName}]`;\n        }\n      }\n    }\n    return frames.join('\\n');\n  }\n  /**\n   * This is ZoneAwareError which processes the stack frame and cleans up extra frames as well as\n   * adds zone information to it.\n   */\n  function ZoneAwareError() {\n    // We always have to return native error otherwise the browser console will not work.\n    let error = NativeError.apply(this, arguments);\n    // Save original stack trace\n    const originalStack = error['originalStack'] = error.stack;\n    // Process the stack trace and rewrite the frames.\n    if (ZoneAwareError[stackRewrite] && originalStack) {\n      let zoneFrame = api.currentZoneFrame();\n      if (zoneJsInternalStackFramesPolicy === 'lazy') {\n        // don't handle stack trace now\n        error[api.symbol('zoneFrameNames')] = buildZoneFrameNames(zoneFrame);\n      } else if (zoneJsInternalStackFramesPolicy === 'default') {\n        try {\n          error.stack = error.zoneAwareStack = buildZoneAwareStackFrames(originalStack, zoneFrame);\n        } catch (e) {\n          // ignore as some browsers don't allow overriding of stack\n        }\n      }\n    }\n    if (this instanceof NativeError && this.constructor != NativeError) {\n      // We got called with a `new` operator AND we are subclass of ZoneAwareError\n      // in that case we have to copy all of our properties to `this`.\n      Object.keys(error).concat('stack', 'message').forEach(key => {\n        const value = error[key];\n        if (value !== undefined) {\n          try {\n            this[key] = value;\n          } catch (e) {\n            // ignore the assignment in case it is a setter and it throws.\n          }\n        }\n      });\n      return this;\n    }\n    return error;\n  }\n  // Copy the prototype so that instanceof operator works as expected\n  ZoneAwareError.prototype = NativeError.prototype;\n  ZoneAwareError[zoneJsInternalStackFramesSymbol] = zoneJsInternalStackFrames;\n  ZoneAwareError[stackRewrite] = false;\n  const zoneAwareStackSymbol = api.symbol('zoneAwareStack');\n  // try to define zoneAwareStack property when zoneJsInternal frames policy is delay\n  if (zoneJsInternalStackFramesPolicy === 'lazy') {\n    Object.defineProperty(ZoneAwareError.prototype, 'zoneAwareStack', {\n      configurable: true,\n      enumerable: true,\n      get: function () {\n        if (!this[zoneAwareStackSymbol]) {\n          this[zoneAwareStackSymbol] = buildZoneAwareStackFrames(this.originalStack, this[api.symbol('zoneFrameNames')], false);\n        }\n        return this[zoneAwareStackSymbol];\n      },\n      set: function (newStack) {\n        this.originalStack = newStack;\n        this[zoneAwareStackSymbol] = buildZoneAwareStackFrames(this.originalStack, this[api.symbol('zoneFrameNames')], false);\n      }\n    });\n  }\n  // those properties need special handling\n  const specialPropertyNames = ['stackTraceLimit', 'captureStackTrace', 'prepareStackTrace'];\n  // those properties of NativeError should be set to ZoneAwareError\n  const nativeErrorProperties = Object.keys(NativeError);\n  if (nativeErrorProperties) {\n    nativeErrorProperties.forEach(prop => {\n      if (specialPropertyNames.filter(sp => sp === prop).length === 0) {\n        Object.defineProperty(ZoneAwareError, prop, {\n          get: function () {\n            return NativeError[prop];\n          },\n          set: function (value) {\n            NativeError[prop] = value;\n          }\n        });\n      }\n    });\n  }\n  if (NativeError.hasOwnProperty('stackTraceLimit')) {\n    // Extend default stack limit as we will be removing few frames.\n    NativeError.stackTraceLimit = Math.max(NativeError.stackTraceLimit, 15);\n    // make sure that ZoneAwareError has the same property which forwards to NativeError.\n    Object.defineProperty(ZoneAwareError, 'stackTraceLimit', {\n      get: function () {\n        return NativeError.stackTraceLimit;\n      },\n      set: function (value) {\n        return NativeError.stackTraceLimit = value;\n      }\n    });\n  }\n  if (NativeError.hasOwnProperty('captureStackTrace')) {\n    Object.defineProperty(ZoneAwareError, 'captureStackTrace', {\n      // add named function here because we need to remove this\n      // stack frame when prepareStackTrace below\n      value: function zoneCaptureStackTrace(targetObject, constructorOpt) {\n        NativeError.captureStackTrace(targetObject, constructorOpt);\n      }\n    });\n  }\n  const ZONE_CAPTURESTACKTRACE = 'zoneCaptureStackTrace';\n  Object.defineProperty(ZoneAwareError, 'prepareStackTrace', {\n    get: function () {\n      return NativeError.prepareStackTrace;\n    },\n    set: function (value) {\n      if (!value || typeof value !== 'function') {\n        return NativeError.prepareStackTrace = value;\n      }\n      return NativeError.prepareStackTrace = function (error, structuredStackTrace) {\n        // remove additional stack information from ZoneAwareError.captureStackTrace\n        if (structuredStackTrace) {\n          for (let i = 0; i < structuredStackTrace.length; i++) {\n            const st = structuredStackTrace[i];\n            // remove the first function which name is zoneCaptureStackTrace\n            if (st.getFunctionName() === ZONE_CAPTURESTACKTRACE) {\n              structuredStackTrace.splice(i, 1);\n              break;\n            }\n          }\n        }\n        return value.call(this, error, structuredStackTrace);\n      };\n    }\n  });\n  if (zoneJsInternalStackFramesPolicy === 'disable') {\n    // don't need to run detectZone to populate zoneJs internal stack frames\n    return;\n  }\n  // Now we need to populate the `zoneJsInternalStackFrames` as well as find the\n  // run/runGuarded/runTask frames. This is done by creating a detect zone and then threading\n  // the execution through all of the above methods so that we can look at the stack trace and\n  // find the frames of interest.\n  let detectZone = Zone.current.fork({\n    name: 'detect',\n    onHandleError: function (parentZD, current, target, error) {\n      if (error.originalStack && Error === ZoneAwareError) {\n        let frames = error.originalStack.split(/\\n/);\n        let runFrame = false,\n          runGuardedFrame = false,\n          runTaskFrame = false;\n        while (frames.length) {\n          let frame = frames.shift();\n          // On safari it is possible to have stack frame with no line number.\n          // This check makes sure that we don't filter frames on name only (must have\n          // line number or exact equals to `ZoneAwareError`)\n          if (/:\\d+:\\d+/.test(frame) || frame === 'ZoneAwareError') {\n            // Get rid of the path so that we don't accidentally find function name in path.\n            // In chrome the separator is `(` and `@` in FF and safari\n            // Chrome: at Zone.run (zone.js:100)\n            // Chrome: at Zone.run (http://localhost:9876/base/build/lib/zone.js:100:24)\n            // FireFox: Zone.prototype.run@http://localhost:9876/base/build/lib/zone.js:101:24\n            // Safari: run@http://localhost:9876/base/build/lib/zone.js:101:24\n            let fnName = frame.split('(')[0].split('@')[0];\n            let frameType = 1 /* FrameType.transition */;\n            if (fnName.indexOf('ZoneAwareError') !== -1) {\n              if (fnName.indexOf('new ZoneAwareError') !== -1) {\n                zoneAwareFrame1 = frame;\n                zoneAwareFrame2 = frame.replace('new ZoneAwareError', 'new Error.ZoneAwareError');\n              } else {\n                zoneAwareFrame1WithoutNew = frame;\n                zoneAwareFrame2WithoutNew = frame.replace('Error.', '');\n                if (frame.indexOf('Error.ZoneAwareError') === -1) {\n                  zoneAwareFrame3WithoutNew = frame.replace('ZoneAwareError', 'Error.ZoneAwareError');\n                }\n              }\n              zoneJsInternalStackFrames[zoneAwareFrame2] = 0 /* FrameType.zoneJsInternal */;\n            }\n\n            if (fnName.indexOf('runGuarded') !== -1) {\n              runGuardedFrame = true;\n            } else if (fnName.indexOf('runTask') !== -1) {\n              runTaskFrame = true;\n            } else if (fnName.indexOf('run') !== -1) {\n              runFrame = true;\n            } else {\n              frameType = 0 /* FrameType.zoneJsInternal */;\n            }\n\n            zoneJsInternalStackFrames[frame] = frameType;\n            // Once we find all of the frames we can stop looking.\n            if (runFrame && runGuardedFrame && runTaskFrame) {\n              ZoneAwareError[stackRewrite] = true;\n              break;\n            }\n          }\n        }\n      }\n      return false;\n    }\n  });\n  // carefully constructor a stack frame which contains all of the frames of interest which\n  // need to be detected and marked as an internal zoneJs frame.\n  const childDetectZone = detectZone.fork({\n    name: 'child',\n    onScheduleTask: function (delegate, curr, target, task) {\n      return delegate.scheduleTask(target, task);\n    },\n    onInvokeTask: function (delegate, curr, target, task, applyThis, applyArgs) {\n      return delegate.invokeTask(target, task, applyThis, applyArgs);\n    },\n    onCancelTask: function (delegate, curr, target, task) {\n      return delegate.cancelTask(target, task);\n    },\n    onInvoke: function (delegate, curr, target, callback, applyThis, applyArgs, source) {\n      return delegate.invoke(target, callback, applyThis, applyArgs, source);\n    }\n  });\n  // we need to detect all zone related frames, it will\n  // exceed default stackTraceLimit, so we set it to\n  // larger number here, and restore it after detect finish.\n  // We cast through any so we don't need to depend on nodejs typings.\n  const originalStackTraceLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 100;\n  // we schedule event/micro/macro task, and invoke them\n  // when onSchedule, so we can get all stack traces for\n  // all kinds of tasks with one error thrown.\n  childDetectZone.run(() => {\n    childDetectZone.runGuarded(() => {\n      const fakeTransitionTo = () => {};\n      childDetectZone.scheduleEventTask(zoneJsInternalStackFramesSymbol, () => {\n        childDetectZone.scheduleMacroTask(zoneJsInternalStackFramesSymbol, () => {\n          childDetectZone.scheduleMicroTask(zoneJsInternalStackFramesSymbol, () => {\n            throw new Error();\n          }, undefined, t => {\n            t._transitionTo = fakeTransitionTo;\n            t.invoke();\n          });\n          childDetectZone.scheduleMicroTask(zoneJsInternalStackFramesSymbol, () => {\n            throw Error();\n          }, undefined, t => {\n            t._transitionTo = fakeTransitionTo;\n            t.invoke();\n          });\n        }, undefined, t => {\n          t._transitionTo = fakeTransitionTo;\n          t.invoke();\n        }, () => {});\n      }, undefined, t => {\n        t._transitionTo = fakeTransitionTo;\n        t.invoke();\n      }, () => {});\n    });\n  });\n  Error.stackTraceLimit = originalStackTraceLimit;\n});","map":{"version":3,"names":["Zone","__load_patch","global","api","zoneJsInternalStackFramesSymbol","symbol","NativeError","zoneJsInternalStackFrames","zoneAwareFrame1","zoneAwareFrame2","zoneAwareFrame1WithoutNew","zoneAwareFrame2WithoutNew","zoneAwareFrame3WithoutNew","ZoneAwareError","stackRewrite","zoneJsInternalStackFramesPolicy","buildZoneFrameNames","zoneFrame","zoneFrameName","zoneName","zone","name","result","parent","parentZoneFrameName","buildZoneAwareStackFrames","originalStack","isZoneFrame","frames","split","i","length","frame","trim","splice","join","error","apply","arguments","stack","currentZoneFrame","zoneAwareStack","e","constructor","Object","keys","concat","forEach","key","value","undefined","prototype","zoneAwareStackSymbol","defineProperty","configurable","enumerable","get","set","newStack","specialPropertyNames","nativeErrorProperties","prop","filter","sp","hasOwnProperty","stackTraceLimit","Math","max","zoneCaptureStackTrace","targetObject","constructorOpt","captureStackTrace","ZONE_CAPTURESTACKTRACE","prepareStackTrace","structuredStackTrace","st","getFunctionName","call","detectZone","current","fork","onHandleError","parentZD","target","Error","runFrame","runGuardedFrame","runTaskFrame","shift","test","fnName","frameType","indexOf","replace","childDetectZone","onScheduleTask","delegate","curr","task","scheduleTask","onInvokeTask","applyThis","applyArgs","invokeTask","onCancelTask","cancelTask","onInvoke","callback","source","invoke","originalStackTraceLimit","run","runGuarded","fakeTransitionTo","scheduleEventTask","scheduleMacroTask","scheduleMicroTask","t","_transitionTo"],"sources":["/Users/richardash/Dev/RecruiterLite/RecruiterLite/ClientApp/node_modules/zone.js/fesm2015/zone-error.js"],"sourcesContent":["'use strict';\n/**\n * @license Angular v<unknown>\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n/**\n * @fileoverview\n * @suppress {globalThis,undefinedVars}\n */\nZone.__load_patch('Error', (global, Zone, api) => {\n    /*\n     * This code patches Error so that:\n     *   - It ignores un-needed stack frames.\n     *   - It Shows the associated Zone for reach frame.\n     */\n    const zoneJsInternalStackFramesSymbol = api.symbol('zoneJsInternalStackFrames');\n    const NativeError = global[api.symbol('Error')] = global['Error'];\n    // Store the frames which should be removed from the stack frames\n    const zoneJsInternalStackFrames = {};\n    // We must find the frame where Error was created, otherwise we assume we don't understand stack\n    let zoneAwareFrame1;\n    let zoneAwareFrame2;\n    let zoneAwareFrame1WithoutNew;\n    let zoneAwareFrame2WithoutNew;\n    let zoneAwareFrame3WithoutNew;\n    global['Error'] = ZoneAwareError;\n    const stackRewrite = 'stackRewrite';\n    const zoneJsInternalStackFramesPolicy = global['__Zone_Error_BlacklistedStackFrames_policy'] ||\n        global['__Zone_Error_ZoneJsInternalStackFrames_policy'] || 'default';\n    function buildZoneFrameNames(zoneFrame) {\n        let zoneFrameName = { zoneName: zoneFrame.zone.name };\n        let result = zoneFrameName;\n        while (zoneFrame.parent) {\n            zoneFrame = zoneFrame.parent;\n            const parentZoneFrameName = { zoneName: zoneFrame.zone.name };\n            zoneFrameName.parent = parentZoneFrameName;\n            zoneFrameName = parentZoneFrameName;\n        }\n        return result;\n    }\n    function buildZoneAwareStackFrames(originalStack, zoneFrame, isZoneFrame = true) {\n        let frames = originalStack.split('\\n');\n        let i = 0;\n        // Find the first frame\n        while (!(frames[i] === zoneAwareFrame1 || frames[i] === zoneAwareFrame2 ||\n            frames[i] === zoneAwareFrame1WithoutNew || frames[i] === zoneAwareFrame2WithoutNew ||\n            frames[i] === zoneAwareFrame3WithoutNew) &&\n            i < frames.length) {\n            i++;\n        }\n        for (; i < frames.length && zoneFrame; i++) {\n            let frame = frames[i];\n            if (frame.trim()) {\n                switch (zoneJsInternalStackFrames[frame]) {\n                    case 0 /* FrameType.zoneJsInternal */:\n                        frames.splice(i, 1);\n                        i--;\n                        break;\n                    case 1 /* FrameType.transition */:\n                        if (zoneFrame.parent) {\n                            // This is the special frame where zone changed. Print and process it accordingly\n                            zoneFrame = zoneFrame.parent;\n                        }\n                        else {\n                            zoneFrame = null;\n                        }\n                        frames.splice(i, 1);\n                        i--;\n                        break;\n                    default:\n                        frames[i] += isZoneFrame ? ` [${zoneFrame.zone.name}]` :\n                            ` [${zoneFrame.zoneName}]`;\n                }\n            }\n        }\n        return frames.join('\\n');\n    }\n    /**\n     * This is ZoneAwareError which processes the stack frame and cleans up extra frames as well as\n     * adds zone information to it.\n     */\n    function ZoneAwareError() {\n        // We always have to return native error otherwise the browser console will not work.\n        let error = NativeError.apply(this, arguments);\n        // Save original stack trace\n        const originalStack = error['originalStack'] = error.stack;\n        // Process the stack trace and rewrite the frames.\n        if (ZoneAwareError[stackRewrite] && originalStack) {\n            let zoneFrame = api.currentZoneFrame();\n            if (zoneJsInternalStackFramesPolicy === 'lazy') {\n                // don't handle stack trace now\n                error[api.symbol('zoneFrameNames')] = buildZoneFrameNames(zoneFrame);\n            }\n            else if (zoneJsInternalStackFramesPolicy === 'default') {\n                try {\n                    error.stack = error.zoneAwareStack = buildZoneAwareStackFrames(originalStack, zoneFrame);\n                }\n                catch (e) {\n                    // ignore as some browsers don't allow overriding of stack\n                }\n            }\n        }\n        if (this instanceof NativeError && this.constructor != NativeError) {\n            // We got called with a `new` operator AND we are subclass of ZoneAwareError\n            // in that case we have to copy all of our properties to `this`.\n            Object.keys(error).concat('stack', 'message').forEach((key) => {\n                const value = error[key];\n                if (value !== undefined) {\n                    try {\n                        this[key] = value;\n                    }\n                    catch (e) {\n                        // ignore the assignment in case it is a setter and it throws.\n                    }\n                }\n            });\n            return this;\n        }\n        return error;\n    }\n    // Copy the prototype so that instanceof operator works as expected\n    ZoneAwareError.prototype = NativeError.prototype;\n    ZoneAwareError[zoneJsInternalStackFramesSymbol] = zoneJsInternalStackFrames;\n    ZoneAwareError[stackRewrite] = false;\n    const zoneAwareStackSymbol = api.symbol('zoneAwareStack');\n    // try to define zoneAwareStack property when zoneJsInternal frames policy is delay\n    if (zoneJsInternalStackFramesPolicy === 'lazy') {\n        Object.defineProperty(ZoneAwareError.prototype, 'zoneAwareStack', {\n            configurable: true,\n            enumerable: true,\n            get: function () {\n                if (!this[zoneAwareStackSymbol]) {\n                    this[zoneAwareStackSymbol] = buildZoneAwareStackFrames(this.originalStack, this[api.symbol('zoneFrameNames')], false);\n                }\n                return this[zoneAwareStackSymbol];\n            },\n            set: function (newStack) {\n                this.originalStack = newStack;\n                this[zoneAwareStackSymbol] = buildZoneAwareStackFrames(this.originalStack, this[api.symbol('zoneFrameNames')], false);\n            }\n        });\n    }\n    // those properties need special handling\n    const specialPropertyNames = ['stackTraceLimit', 'captureStackTrace', 'prepareStackTrace'];\n    // those properties of NativeError should be set to ZoneAwareError\n    const nativeErrorProperties = Object.keys(NativeError);\n    if (nativeErrorProperties) {\n        nativeErrorProperties.forEach(prop => {\n            if (specialPropertyNames.filter(sp => sp === prop).length === 0) {\n                Object.defineProperty(ZoneAwareError, prop, {\n                    get: function () {\n                        return NativeError[prop];\n                    },\n                    set: function (value) {\n                        NativeError[prop] = value;\n                    }\n                });\n            }\n        });\n    }\n    if (NativeError.hasOwnProperty('stackTraceLimit')) {\n        // Extend default stack limit as we will be removing few frames.\n        NativeError.stackTraceLimit = Math.max(NativeError.stackTraceLimit, 15);\n        // make sure that ZoneAwareError has the same property which forwards to NativeError.\n        Object.defineProperty(ZoneAwareError, 'stackTraceLimit', {\n            get: function () {\n                return NativeError.stackTraceLimit;\n            },\n            set: function (value) {\n                return NativeError.stackTraceLimit = value;\n            }\n        });\n    }\n    if (NativeError.hasOwnProperty('captureStackTrace')) {\n        Object.defineProperty(ZoneAwareError, 'captureStackTrace', {\n            // add named function here because we need to remove this\n            // stack frame when prepareStackTrace below\n            value: function zoneCaptureStackTrace(targetObject, constructorOpt) {\n                NativeError.captureStackTrace(targetObject, constructorOpt);\n            }\n        });\n    }\n    const ZONE_CAPTURESTACKTRACE = 'zoneCaptureStackTrace';\n    Object.defineProperty(ZoneAwareError, 'prepareStackTrace', {\n        get: function () {\n            return NativeError.prepareStackTrace;\n        },\n        set: function (value) {\n            if (!value || typeof value !== 'function') {\n                return NativeError.prepareStackTrace = value;\n            }\n            return NativeError.prepareStackTrace = function (error, structuredStackTrace) {\n                // remove additional stack information from ZoneAwareError.captureStackTrace\n                if (structuredStackTrace) {\n                    for (let i = 0; i < structuredStackTrace.length; i++) {\n                        const st = structuredStackTrace[i];\n                        // remove the first function which name is zoneCaptureStackTrace\n                        if (st.getFunctionName() === ZONE_CAPTURESTACKTRACE) {\n                            structuredStackTrace.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n                return value.call(this, error, structuredStackTrace);\n            };\n        }\n    });\n    if (zoneJsInternalStackFramesPolicy === 'disable') {\n        // don't need to run detectZone to populate zoneJs internal stack frames\n        return;\n    }\n    // Now we need to populate the `zoneJsInternalStackFrames` as well as find the\n    // run/runGuarded/runTask frames. This is done by creating a detect zone and then threading\n    // the execution through all of the above methods so that we can look at the stack trace and\n    // find the frames of interest.\n    let detectZone = Zone.current.fork({\n        name: 'detect',\n        onHandleError: function (parentZD, current, target, error) {\n            if (error.originalStack && Error === ZoneAwareError) {\n                let frames = error.originalStack.split(/\\n/);\n                let runFrame = false, runGuardedFrame = false, runTaskFrame = false;\n                while (frames.length) {\n                    let frame = frames.shift();\n                    // On safari it is possible to have stack frame with no line number.\n                    // This check makes sure that we don't filter frames on name only (must have\n                    // line number or exact equals to `ZoneAwareError`)\n                    if (/:\\d+:\\d+/.test(frame) || frame === 'ZoneAwareError') {\n                        // Get rid of the path so that we don't accidentally find function name in path.\n                        // In chrome the separator is `(` and `@` in FF and safari\n                        // Chrome: at Zone.run (zone.js:100)\n                        // Chrome: at Zone.run (http://localhost:9876/base/build/lib/zone.js:100:24)\n                        // FireFox: Zone.prototype.run@http://localhost:9876/base/build/lib/zone.js:101:24\n                        // Safari: run@http://localhost:9876/base/build/lib/zone.js:101:24\n                        let fnName = frame.split('(')[0].split('@')[0];\n                        let frameType = 1 /* FrameType.transition */;\n                        if (fnName.indexOf('ZoneAwareError') !== -1) {\n                            if (fnName.indexOf('new ZoneAwareError') !== -1) {\n                                zoneAwareFrame1 = frame;\n                                zoneAwareFrame2 = frame.replace('new ZoneAwareError', 'new Error.ZoneAwareError');\n                            }\n                            else {\n                                zoneAwareFrame1WithoutNew = frame;\n                                zoneAwareFrame2WithoutNew = frame.replace('Error.', '');\n                                if (frame.indexOf('Error.ZoneAwareError') === -1) {\n                                    zoneAwareFrame3WithoutNew =\n                                        frame.replace('ZoneAwareError', 'Error.ZoneAwareError');\n                                }\n                            }\n                            zoneJsInternalStackFrames[zoneAwareFrame2] = 0 /* FrameType.zoneJsInternal */;\n                        }\n                        if (fnName.indexOf('runGuarded') !== -1) {\n                            runGuardedFrame = true;\n                        }\n                        else if (fnName.indexOf('runTask') !== -1) {\n                            runTaskFrame = true;\n                        }\n                        else if (fnName.indexOf('run') !== -1) {\n                            runFrame = true;\n                        }\n                        else {\n                            frameType = 0 /* FrameType.zoneJsInternal */;\n                        }\n                        zoneJsInternalStackFrames[frame] = frameType;\n                        // Once we find all of the frames we can stop looking.\n                        if (runFrame && runGuardedFrame && runTaskFrame) {\n                            ZoneAwareError[stackRewrite] = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n    });\n    // carefully constructor a stack frame which contains all of the frames of interest which\n    // need to be detected and marked as an internal zoneJs frame.\n    const childDetectZone = detectZone.fork({\n        name: 'child',\n        onScheduleTask: function (delegate, curr, target, task) {\n            return delegate.scheduleTask(target, task);\n        },\n        onInvokeTask: function (delegate, curr, target, task, applyThis, applyArgs) {\n            return delegate.invokeTask(target, task, applyThis, applyArgs);\n        },\n        onCancelTask: function (delegate, curr, target, task) {\n            return delegate.cancelTask(target, task);\n        },\n        onInvoke: function (delegate, curr, target, callback, applyThis, applyArgs, source) {\n            return delegate.invoke(target, callback, applyThis, applyArgs, source);\n        }\n    });\n    // we need to detect all zone related frames, it will\n    // exceed default stackTraceLimit, so we set it to\n    // larger number here, and restore it after detect finish.\n    // We cast through any so we don't need to depend on nodejs typings.\n    const originalStackTraceLimit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 100;\n    // we schedule event/micro/macro task, and invoke them\n    // when onSchedule, so we can get all stack traces for\n    // all kinds of tasks with one error thrown.\n    childDetectZone.run(() => {\n        childDetectZone.runGuarded(() => {\n            const fakeTransitionTo = () => { };\n            childDetectZone.scheduleEventTask(zoneJsInternalStackFramesSymbol, () => {\n                childDetectZone.scheduleMacroTask(zoneJsInternalStackFramesSymbol, () => {\n                    childDetectZone.scheduleMicroTask(zoneJsInternalStackFramesSymbol, () => {\n                        throw new Error();\n                    }, undefined, (t) => {\n                        t._transitionTo = fakeTransitionTo;\n                        t.invoke();\n                    });\n                    childDetectZone.scheduleMicroTask(zoneJsInternalStackFramesSymbol, () => {\n                        throw Error();\n                    }, undefined, (t) => {\n                        t._transitionTo = fakeTransitionTo;\n                        t.invoke();\n                    });\n                }, undefined, (t) => {\n                    t._transitionTo = fakeTransitionTo;\n                    t.invoke();\n                }, () => { });\n            }, undefined, (t) => {\n                t._transitionTo = fakeTransitionTo;\n                t.invoke();\n            }, () => { });\n        });\n    });\n    Error.stackTraceLimit = originalStackTraceLimit;\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}